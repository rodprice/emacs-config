#+TITLE: Emacs configuration for shells
#+STARTUP: overview indent

* Preliminaries

All functions below use lexical binding.
#+begin_src emacs-lisp
;; -*- coding: utf-8; lexical-binding: t -*-
(message "... starting settings-shells")
#+end_src

This configuration requires packages

  - powershell

* Notes

Installation [[https://github.com/akermu/emacs-libvterm/#requirements][instructions]] for [[https://github.com/akermu/emacs-libvterm][emacs-libvterm]]. Doesn't work for Windows.
Toggle between a buffer and vterm ([[https://github.com/akermu/emacs-libvterm/#requirements][vterm-toggle]]).

A possibly useful blog post: [[https://www.eigenbahn.com/2020/01/21/painless-emacs-interactive-shells][Painless Emacs interactive shells]].

A guy who says he uses =zsh= on Windows, [[https://www.reddit.com/r/emacs/comments/n8jd7z/emacs_msys2_windows_task_scheduler_a_love_story/][here]]. (Also has daemon setup.)

This code is in my =.bash_profile=, defining the =bash= prompt. The
=myprompt= function, together with =PROMPT_COMMAND=, enables directory
tracking, per this [[https://www.masteringemacs.org/article/running-shells-in-emacs-overview][article]].
#+begin_src shell :tangle no
    # printf "\x1b[38;2;40;177;249mTRUECOLOR\x1b[0m\n"
    # printf "\x1b[38;2;197;134;192mVIOLET\x1b[0m\n"
    # printf "\x1b[38;2;78;201;176mGREEN\x1b[0m\n"
    # printf "\x1b[38;2;255;195;0mYELLOW\x1b[0m\n"
    if [ -n "$INSIDE_EMACS" ]; then
        CONDAENV="\033[38;2;78;201;176m$(parse_conda_env)\033[0m"
        DIRNAME="\033[38;2;255;195;0m\w\033[0m"
        GITSTATUS="\033[38;2;197;134;192m$(__git_ps1)\033[0m"
        if [ ! -z "$FOUND_GIT_PROMPT_SH" ];then
            export PS1="${CONDAENV}${DIRNAME}${GITSTATUS} $ "
        else
            export PS1="${CONDAENV}${DIRNAME} $ "
        fi
        unset CONDAENV DIRNAME GITSTATUS
#+end_src

This guy [[https://www.masteringemacs.org/article/running-shells-in-emacs-overview][says]] the following is needed in =.bash_profile=. He's wrong.
#+begin_src shell :tangle no
        function myprompt () {
            printf "\e]7;file://%s%s\e\\" "$HOSTNAME" "$PWD"
        }
        PROMPT_COMMAND=myprompt
    fi
#+end_src

A useful StackExchange answer about ANSI color escape codes is [[https://stackoverflow.com/questions/4842424/list-of-ansi-color-escape-sequences][here]].

* Comint processes

Close the window containing the interpreter and kill its buffer when
the interpreter exits. Adapted from a StackExchange answer [[https://emacs.stackexchange.com/questions/48306/how-to-automatically-kill-a-shell-buffer-when-the-shell-process-exits][here]].
#+begin_src emacs-lisp
  (defun my-add-kill-buffer-sentinel ()
    "Set a process sentinel that kills the buffer when the process exits."
    (let ((process (get-buffer-process (current-buffer))))
      (when (null process)
        (error "No process in buffer %s" (buffer-name (current-buffer))))
      (let ((sentinel (process-sentinel process)))
        (set-process-sentinel
         process
         `(lambda (process signal)
            ;; Call the original process sentinel first.
            (funcall #',sentinel process signal)
            ;; Kill the buffer on an exit signal.
            (when (memq (process-status process) '(exit signal))
              (let ((buffer (process-buffer process)))
                (when (buffer-live-p buffer)
                  (quit-window t (get-buffer-window buffer))))))))))
#+end_src

Rather than signal an error if there is no process, fail silently.
#+begin_src emacs-lisp
  (defun my-add-kill-buffer-sentinel-quiet ()
    "Set a process sentinel that kills the buffer when the process exits."
    (let ((process (get-buffer-process (current-buffer))))
      (unless (null process)
        (let ((sentinel (process-sentinel process)))
          (set-process-sentinel
           process
           `(lambda (process signal)
              ;; Call the original process sentinel first.
              (funcall #',sentinel process signal)
              ;; Kill the buffer on an exit signal.
              (when (memq (process-status process) '(exit signal))
                (let ((buffer (process-buffer process)))
                  (when (buffer-live-p buffer)
                    (quit-window t (get-buffer-window buffer)))))))))))
#+end_src

* Shell

** Notes

[[https://github.com/atomontage/xterm-color][xterm-color]] for better color emulation, supposedly. Mastering Emacs
has a nice [[https://www.masteringemacs.org/article/running-shells-in-emacs-overview][introduction]] to running shells. The configuration below
starts with error message "no job control in this shell"; there's a
discussion on [[https://emacs.stackexchange.com/questions/71487/mingw-shell-in-emacs][StackExchange]]. Another possible hint involving
=system-uses-terminfo= [[https://stackoverflow.com/questions/39761234/git-bash-for-windows-not-working-lein-repl-command][here]].

** Shell package

#+begin_src emacs-lisp
  (defun my-get-shell-file-name (&optional shell-name)
    "Return the explicit path to SHELL-NAME, based on `system-type'
and the variables defined in the `site/<hostname>-preload.el' file.
If SHELL-NAME is nil, use \"bash\"."
      (let ((shell-name (or shell-name "bash")))
        (cond ((eq system-type 'windows-nt)
               (if (bound-and-true-p my-mingw-dir)
                   (expand-file-name
                    (concat
                     (file-name-directory my-mingw-dir)
                     (format "usr/bin/%s.exe" shell-name)))
                 (user-error "Site-specific variable 'my-mingw-dir is undefined.")))
              (t
               (executable-find shell-name)))))
#+end_src

#+begin_src emacs-lisp
  (defun my-close-shell-window ()
    "Close the shell window without killing its buffer or process."
    (interactive)
    (let ((buffer (current-buffer)))
      (unless (eq
               (alist-get'major-mode (buffer-local-variables buffer))
               'shell-mode)
        (user-error "Buffer '%s' is not running a shell." buffer))
      (let ((window (get-buffer-window buffer)))
        ;; Borrowed from popper.el
        (when (window-valid-p window)
          (cond
           ((window-parent window)
            (if (window-parameter window 'window-side)
                (delete-window window)
              (quit-window nil window)))
           ((frame-parent) (delete-frame))
           (t (quit-window nil window)))))))
#+end_src

#+begin_src emacs-lisp
  (defun my-fix-shell-prompt-colors ()
    "Leave comint buffer background in the prompt alone."
    (face-remap-set-base 'comint-highlight-prompt :inherit nil))
#+end_src

#+begin_src emacs-lisp
  (use-package shell
    :defer t
    :custom
    (shell-command-default-error-buffer "*Shell Errors*")
    :config
    (setq explicit-shell-file-name (my-get-shell-file-name))
    (setq shell-file-name explicit-shell-file-name)
    (setenv "SHELL" explicit-shell-file-name)
    (setq explicit-bash.exe-args (list "-i" "-l"))
    (setq system-uses-terminfo t)  ;; has no effect, apparently
    (add-hook 'comint-output-filter-functions #'shell-filter-ring-bell nil t)
    :bind
    (("<f6>" . shell)
     (:map shell-mode-map
           ("<f6>" . my-close-shell-window)))
    :hook
    ((shell-mode . my-add-kill-buffer-sentinel)
     (shell-mode . my-fix-shell-prompt-colors)))
#+end_src

** Shell commands

If you want the output buffer for asynchronous shell commands to be
displayed only when the command generates output, set
‘async-shell-command-display-buffer’ to ‘nil’.

If ‘shell-command-prompt-show-cwd’ is non-nil, show the current
directory in the prompt.

** Shell dwim

Might be interesting for quick shortcuts. From [[https://github.com/xenodium/dwim-shell-command][here]].
#+begin_src emacs-lisp :tangle no
(use-package dwim-shell-command
  :ensure t
  :bind (([remap shell-command] . dwim-shell-command)
         :map dired-mode-map
         ([remap dired-do-async-shell-command] . dwim-shell-command)
         ([remap dired-do-shell-command] . dwim-shell-command)
         ([remap dired-smart-shell-command] . dwim-shell-command))
  :config
  (defun my/dwim-shell-command-convert-to-gif ()
    "Convert all marked videos to optimized gif(s)."
    (interactive)
    (dwim-shell-command-on-marked-files
     "Convert to gif"
     "ffmpeg -loglevel quiet -stats -y -i <<f>> -pix_fmt rgb24 -r 15 <<fne>>.gif"
     :utils "ffmpeg")))
#+end_src

** Findutils

Gnu documentation on =findutils= [[https://www.gnu.org/software/findutils/manual/html_mono/find.html][here]].

#+begin_src emacs-lisp
  (defun my-find-command (dir pat)
    "Assemble a `find' command string that will return all
  files matching glob pattern PAT in directory tree DIR."
    (combine-and-quote-strings
     (list "find" dir "-name" pat "-print0")))
#+end_src

#+begin_src emacs-lisp
  (defun my-find-command (dir pat)
    "Assemble a `find' command string that will return all
  files matching glob pattern PAT in directory tree DIR."
    (string-join
     (list
      "find"
      (expand-file-name dir)
      "-name"
      (concat "'" pat "'")
      "-print0")
     " "))
#+end_src

#+begin_src emacs-lisp
      (defun my-find-command-list (dir &rest pats)
        "Assemble a list of `find' command strings that will return all
      files matching glob patterns in list PATS in directory tree DIR."
        (interactive
         (cons
          (read-directory-name "Directory: ")
          (split-string
           (let ((pats (read-string "Patterns: " "*.el *.signed")))
             (if (string-empty-p pats)
                 (user-error "Cancelled")
               pats))
           " ")))
        (let ((dir (expand-file-name (or dir ".")))
              (pats (cond
                     ((null pats) '("*.el" "*.signed"))
                     ((and (stringp pats) (not (string-empty-p pats))) (list pats))
                     ((listp pats) pats)
                     (t (user-error "Invalid patterns '%s'" pats)))))
          (mapcar
           (apply-partially #'my-find-command dir)
           pats)))
#+end_src

#+begin_src emacs-lisp
  (defun my-clean-up-line-endings-inner (pats &optional dir noconfirm)
    "Walk the directory tree DIR, running `dos2unix' on all files
  matching glob patterns PATS, which can be either a string or a
  list of strings. If NOCONFIRM is non-nil, omit confirmation."
    ;; find . -name "*.signed" -print0 | xargs -0 dos2unix
    ;; async-shell-command
    (unless (executable-find "find")
      (user-error "Cannot find 'find' command"))
    (unless (executable-find "dos2unix")
      (user-error "Cannot find 'dos2unix' command"))
    (let ((pats (if (stringp pats) (list pats) pats))
          (dir (expand-file-name (or dir "."))))
      (when (null noconfirm)
        (unless (y-or-n-p
                 (format "Replace all CRLF line endings in '%s'?" dir))
          (user-error "Cancelled")))
      (dolist (pat pats)
        (print
         ;; (async-shell-command
         (my-clean-up-line-endings-command pat dir)))))
#+end_src

Muck around with =exec-path= if we're on Windows.
#+begin_src emacs-lisp
  (defun my-clean-up-line-endings (pats &optional dir noconfirm)
    "Walk the directory tree DIR, running `dos2unix' on all files
  matching glob patterns PATS, which can be either a string or a
  list of strings. If NOCONFIRM is non-nil, omit confirmation."
    (cond
     ((eq system-type 'windows-nt)
      (let ((exec-path my-msys2-extra-paths))
        (my-clean-up-line-endings-inner pats dir noconfirm)))
     (t
      (my-clean-up-line-endings-inner pats dir noconfirm))))
#+end_src

** Junkyard

#+begin_src emacs-lisp
  (defun my-clean-up-line-endings-command-list (dir &optional pats)
    (interactive
     (list
      (read-directory-name "Directory: ")
      (let (pats)
        (while
            (let ((pat
                   (if (null pats)
                       (read-string (format "Patterns (): "))
                     (read-string (format "Patterns %s: " pats)))))
              (if (not (string-empty-p pat))
                  (setq pats (cons pat pats))
                nil)))
        (if (null pats)
            (user-error "Cancelled")
          pats))))
    (let ((dir (expand-file-name (or dir ".")))
          (pats (cond
                 ((null pats) '(".*.el" "*.signed"))
                 ((and (stringp pats) (not (string-empty-p pats))) (list pats))
                 ((listp pats) pats)
                 (t (user-error "Invalid patterns '%s'" pats)))))
      (message "--- DIR is '%s'; PATS is '%s'" dir pats)
      (mapcar
       (apply-partially #'my-clean-up-line-endings-command dir)
       pats)))
#+end_src

* Vterm

Make =vterm= reuse windows. From Mastering Emacs, [[https://www.masteringemacs.org/article/demystifying-emacs-window-manager][Demystifying Emacs' Window Manager]].
#+begin_src emacs-lisp
  (unless (eq system-type 'windows-nt)
    (add-to-list 'display-buffer-alist
                 '("\\*vterm\\*" display-buffer-reuse-mode-window
                   ;; change to `t' to not reuse same window
                   (inhibit-same-window . nil)
                   (mode vterm-mode vterm-copy-mode))))
#+end_src

* Eshell

Support jumping to prompts in eshell ([[https://github.com/minad/consult/wiki#consult-outline-support-for-eshell-prompts][Consult wiki]]).
#+begin_src emacs-lisp
  (use-package eshell
    :preface
    (defun my-set-eshell-regexp ()
      (setq outline-regexp eshell-prompt-regexp))
    :hook (eshell-mode . my-set-eshell-regexp))
#+end_src

* Powershell

Github repo [[https://github.com/jschaf/powershell.el][here]]. Run =M-x powershell= to get a shell.
#+begin_src emacs-lisp
  (when (eq system-type 'windows-nt)
    (use-package powershell
      :ensure t
      :defer t
      :hook
      ((powershell-mode . my-add-kill-buffer-sentinel))))
#+end_src

Close the powershell window without killing its buffer.
#+begin_src emacs-lisp
  (defun my-close-powershell-window ()
    (interactive)
    (let ((buffer (current-buffer))
          (window (get-buffer-window buffer)))
      ;; Borrowed from popper.el
      (when (window-valid-p window)
        (cond
         ((window-parent window)
          (if (window-parameter window 'window-side)
              (delete-window window)
            (quit-window nil window)))
         ((frame-parent) (delete-frame))
         (t (quit-window nil window))))))
#+end_src

* Chat GPT

In order to attach a sentinel to the =chatgpt-shell= process, you have
to advise its initialization function. This function does that.
#+begin_src emacs-lisp
  (defun my-add-shell-maker-sentinel (config)
    "Set a process sentinel that kills the buffer when the process exits."
    (let ((process
           (get-buffer-process
            (shell-maker-buffer shell-maker-config))))
      (unless (null process)
        (let ((sentinel (process-sentinel process)))
          (set-process-sentinel
           process
           `(lambda (process signal)
              ;; Call the original process sentinel first.
              (funcall #',sentinel process signal)
              ;; Kill the buffer on an exit signal.
              (when (memq (process-status process) '(exit signal))
                (let ((buffer (process-buffer process)))
                  (when (buffer-live-p buffer)
                    (quit-window t (get-buffer-window buffer)))))))))))
#+end_src

See [[https://www.masteringemacs.org/article/keeping-secrets-in-emacs-gnupg-auth-sources][Keeping Secrets in Emacs]]. This package can be found on [[https://github.com/xenodium/chatgpt-shell][Github]].
#+begin_src emacs-lisp
  (use-package chatgpt-shell
    :ensure t
    :init
    (advice-add 'shell-maker--initialize :after #'my-add-shell-maker-sentinel)
    :custom
    (auth-sources
     '((:source "~/.emacs.d/secrets/.authinfo.gpg")))
    (chatgpt-shell-openai-key
     (lambda ()
       (auth-source-pick-first-password :host "api.openai.com")))
    :config
    (when (featurep 'popper)
      (add-to-list 'popper-reference-buffers "\\*chatgpt\\*")
      (popper--set-reference-vars)))
#+end_src
