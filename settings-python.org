#+TITLE: Emacs configuration for Python
#+STARTUP: overview indent

* Preliminaries

All functions below use lexical binding.
#+begin_src emacs-lisp
;; -*- coding: utf-8; lexical-binding: t -*-
(message "... starting settings-python")
#+end_src

This configuration requires packages


External programs that should be on =exec-path= are


The file =settings-minimal.org= should be loaded before loading this
file.

* Notes

A blog post, [[https://sqrtminusone.xyz/posts/2021-05-01-org-python/][Replacing Jupyter Notebook with Org Mode]].

Here is a [[https://github.com/palantir/python-language-server#develop-against-vs-code][claim]] that the Python language server can be run "against" VS Code.
Debugger configurations for various languages are [[https://emacs-lsp.github.io/dap-mode/page/configuration/][here]].

I should probably read through the Python page of [[https://wikemacs.org/wiki/Python][WikEmacs]].

A "minimalistic" Python IDE for Emacs, [[https://github.com/abo-abo/lpy][lpy-mode]]. See also [[https://github.com/abo-abo/lispy][lispy]] by the
same author.

Getting Emacs 29 for MacOS: [[https://www.adventuresinwhy.com/post/compiling-emacs-with-tree-sitter/][Compiling Emacs 29 with Tree-sitter]].
An Eglot configuration: [[https://www.adventuresinwhy.com/post/eglot/][Eglot+Tree-sitter in Emacs 29]].
Other useful articles by the same author [[https://www.adventuresinwhy.com/tag/emacs/][here]].

=python-lsp-server= [[https://github.com/python-lsp/python-lsp-server][here]]. Emacs lsp client for python ruff language
server [[https://github.com/emacs-lsp/lsp-mode/issues/3876][here]]. Ruff docs, such as they are, [[https://beta.ruff.rs/docs/][here]].

A list of Python links, [[https://xenodium.com/python-bookmarks/][here]].

The [[https://davidadrian.cc/definitive-data-scientist-setup/]["definitive" data scientist environment setup]], an article about setting
up Python, R, conda, etc on a Ubuntu laptop. Also, wierdly, [[https://whiteboxml.com/blog/the-definitive-data-scientist-environment-setup][here]].

A really excellent article, [[https://martibosch.github.io/jupyter-emacs-universe/][Jupyter in the Emacs universe]], comparing various
approaches to running Jupyter notebooks in Emacs. Conclusion: all of them
have serious drawbacks. :-( Another article, [[https://sqrtminusone.xyz/posts/2021-05-01-org-python/][Replacing Jupyter Notebook
with Org Mode]], covers a lot of ground, too.

Another "definitive" [[https://whiteboxml.com/blog/the-definitive-guide-to-python-virtual-environments-with-conda][article]], a guide to using =conda=, includes detailed
installation instructions for Windows, Linux, and MacOS. It also has a
section on installing Jupyter using =conda=, and instructions for using the
=conda-pack= for packaging up a complete =conda= environment.

Here's an [[https://github.com/martibosch/snakemacs][Emacs setup for Python with conda/mamba]].

[[https://github.com/mwouts/jupytext][Jupytext]] is a Python library for converting Jupyter notebooks to text and
vice-versa. They discuss "paired notebooks," where =.py= and =.ipynb= files
encode the same notebook. The Jupyter [[https://github.com/mwouts/jupytext/blob/main/docs/paired-notebooks.md][documentation]] explains how to pair
files from JupyterLab. The Emacs package [[https://github.com/astoff/code-cells.el][code-cells.el]] is an alternative.

A [[https://www.youtube.com/watch?v=2NPUDYAOgW0][YouTube video]] about editing live notebook cells with Emacs. Perhaps this
is the way to go, if only I can make it through the guy's really irritating
presentation style. Another [[https://www.youtube.com/watch?v=RD0o2pkJBaI][video]], Jupyter in scimacs, might be worthwhile.

Installing Anaconda on Windows with MSYS2: I can find no way to tell =conda=
to look in the MSYS2 home directory =/home/rdprice= for its =.condarc= config
file. Instead, it looks in =C:\Users\rdprice=, so that's where I've left it.
No =condarc= files are created when Anaconda is installed. This [[https://stackoverflow.com/questions/70980562/where-does-conda-get-the-default-configuration-values-without-a-condarc][post]] shows
where to find the initial configuration variables in the Conda source.

Emacs 29 only: Project shells and a new user option 'python-shell-dedicated'.
When called with a prefix argument, 'run-python' now offers the choice
of creating a shell dedicated to the current project.  This shell runs
in the project root directory and is shared among all project buffers.

Without a prefix argument, the kind of shell (buffer-dedicated,
project-dedicated or global) is specified by the new
'python-shell-dedicated' user option.

* Python mode

Set up Python interpreters, code folding, etc.
#+begin_src emacs-lisp
  (use-package python
    :mode ("\\.py[iw]?\\'" . python-mode)
    :interpreter ("python" . python-mode)
    ;; :config
    ;; (require 'dap-python)
    :custom
    (python-indent-guess-indent-offset-verbose nil)
    ;; (python-indent-trigger-commands #'indent-for-tab-command)
    ;; (dap-python-executable "python3")
    ;; (dap-python-debugger 'debugpy)
    :hook
    ((python-mode . imenu-add-menubar-index)
     (python-mode . eldoc-mode)
     (python-mode . origami-mode)
     (python-mode . my-origami-local-fold-replacement)))
#+end_src

#+begin_src emacs-lisp
  (defun my-origami-local-fold-replacement ()
    (set (make-local-variable 'origami-fold-replacement)
         "...\n"))
#+end_src

* Python documentation

This works for system and environment modules, but flaky at project
level. No idea why.
#+begin_src emacs-lisp
  (use-package pydoc
    :ensure t
    :commands pydoc-at-point
    :bind
    ((:map python-mode-map
           ("C-c f" . pydoc-at-point))))
#+end_src

* Python REPL

Set up the IPython interpreter. Hitting key F5 when the current buffer
is in =python-mode= pops up an IPython REPL. Hitting key F5 when the
current buffer is in =inferior-python-mode=, that is, when running the
REPL, closes the window without killing the REPL. Killing the REPL by
typing =exit()=, hitting key C-d, or some other means, closes the REPL
window and kills the REPL buffer.

#+begin_src emacs-lisp
  (use-package python
    :after popper
    :init
    (add-to-list 'popper-reference-buffers "\\*IPython\\*")
    (add-to-list 'popper-reference-buffers 'inferior-python-mode)
    :config
    (add-to-list 'python-shell-completion-native-disabled-interpreters
                 "ipython")
    (popper--set-reference-vars)
    :custom
    ;; (python-shell-interpreter "python3")
    ;; (python-shell-completion-native-enable nil)
    (python-shell-buffer-name "IPython")
    (python-shell-interpreter "ipython")
    :bind
    ((:map python-mode-map
           ("<f5>" . my-python-start-or-switch-repl))
     (:map inferior-python-mode-map
           ("<f5>" . my-close-ipython-window)))
    :hook
    (inferior-python-mode . my-add-kill-buffer-sentinel))
#+end_src

Open a dedicated Python REPL window. From [[https://emacs.stackexchange.com/questions/36520/dedicated-python-shell][StackExchange]].
#+begin_src emacs-lisp
  (defun my-python-start-or-switch-repl ()
    "Start and/or switch to the Python REPL."
    (interactive)
    (if (python-shell-get-process)
        (python-shell-switch-to-shell)
      (let ((default-directory (my-python-repl-dir))
            (msg "Starting %s REPL in '%s'")
            (python-shell-interpreter-args (my-python-repl-args)))
        (message msg
                 python-shell-interpreter
                 (my-python-repl-dir))
        (run-python (python-shell-calculate-command) t t)
        (python-shell-switch-to-shell))))
#+end_src

If in a project, the Python REPL should start in the project root.
#+begin_src emacs-lisp
  (defun my-python-repl-dir ()
    "Return the directory the Python REPL should be started in."
    (if (project-current)
        (project-root (project-current))
      default-directory))
#+end_src

Construct all arguments to the Python REPL, including a pointer to a
Python configuration file in the project itself.
#+begin_src emacs-lisp
  (defun my-python-repl-args (&optional file-name)
    "Return the arguments the Python REPL should be given."
    (let* ((args
            '("-i"
              "--simple-prompt"
              "--pprint"
              "--InteractiveShell.warn_venv=False"
              "--InteractiveShell.display_page=True"))
           (file-name (if file-name file-name "startup.py"))
           (startup-file
            (expand-file-name file-name (my-python-repl-dir)))
           (ipython-exec-files
            (when (file-exists-p startup-file)
              (format "--InteractiveShellApp.exec_files=%s" startup-file))))
      (if (and
           ipython-exec-files
           (string= python-shell-interpreter "ipython")
           (project-current))
          (add-to-list 'args ipython-exec-files t))
      (string-join args " ")))
#+end_src

Close the IPython window without killing its buffer.
#+begin_src emacs-lisp
  (defun my-close-ipython-window ()
    (interactive)
    (let ((buffer (current-buffer)))
      (unless (eq
               (alist-get 'major-mode (buffer-local-variables buffer))
               'inferior-python-mode)
        (user-error "Buffer '%s' is not running a Python interpreter." buffer))
      (let ((window (get-buffer-window buffer)))
        ;; Borrowed from popper.el
        (when (window-valid-p window)
          (cond
           ((window-parent window)
            (if (window-parameter window 'window-side)
                (delete-window window)
              (quit-window nil window)))
           ((frame-parent) (delete-frame))
           (t (quit-window nil window)))))))
#+end_src

Inspect values in the IPython buffer. Github repo [[https://github.com/it-is-wednesday/pyinspect.el][here]].
#+begin_src emacs-lisp
  (use-package pyinspect
    :ensure t
    :bind
    (:map inferior-python-mode-map
          ("C-c i" . pyinspect-inspect-at-point)))
#+end_src

* Jupyter (disabled)

Note: The package =emacs-jupyter= is [[https://github.com/nnicandro/emacs-jupyter][here]]. An article on setting up
Jupyter with Conda is [[https://martinralbrecht.wordpress.com/2020/08/23/conda-jupyter-and-emacs/][here]].
#+begin_src emacs-lisp :tangle no
  (use-package jupyter
    :after (ob-jupyter ob-python)
    :config
    (setq jupyter-api-authentication-method 'password)
    (setq jupyter-eval-use-overlays nil)
    (setq org-babel-default-header-args:jupyter-python '((:session . "/jpy:localhost#8888:py")
                                                         (:kernel . "conda-env-edge-py")
                                                         (:async . "yes")
                                                         (:pandoc t)))
    (add-to-list 'savehist-additional-variables 'jupyter-server-kernel-names)
    (setq ob-async-no-async-languages-alist '("jupyter-python"))
    (add-to-list 'org-structure-template-alist '("jp" . "src jupyter-python")))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package jupyter
    :ensure t
    :commands (jupyter-run-server-repl
               jupyter-run-repl
               jupyter-server-list-kernels))
#+end_src

* Environment variables (disabled)

See [[https://emacs.stackexchange.com/questions/31282/unicodeencodeerror-executing-python-in-emacs-not-in-terminal][UnicodeEncodeError executing Python in Emacs]].
#+begin_src emacs-lisp
  (setenv "PYTHONIOENCODING" "utf-8")
#+end_src

The [[https://github.com/wbolster/emacs-direnv][direnv]] package maintains a consistent set of environment variables
depending on which project the current buffer is in. There appears to
be no Windows-compatible version.
#+begin_src emacs-lisp
  (use-package direnv
    :disabled
    :ensure t
    :config
    (add-to-list 'warning-suppress-types '(direnv)))
#+end_src

* Virtual environments

** Notes

Note: Another possibly interesting approach is [[https://github.com/10sr/with-venv-el][with-venv.el]], which
sets up a macro =(with-venv BODY)= that ensures that =BODY= runs in the
correct virtual environment. The function =conda-with-env= in conda.el
claims to do this as well.

Note: Here's an emacs [[https://sqrtminusone.xyz/configs/emacs/#anaconda][config]] that advises conda.el functions to keep
track of

** Conda setup

Make sure that prerequisites are available.
#+begin_src emacs-lisp
  (use-package pythonic
    :ensure t)
#+end_src

This uses a modified [[file:lisp/conda.el][conda.el]] package that works on Windows, not the
one found in Melpa. I've forked it on Github [[https://github.com/rodprice/conda.el][here]].
#+begin_src emacs-lisp
  (use-package conda
    :ensure nil
    :after pythonic
    :load-path "lisp"
    :custom
    (conda-anaconda-home my-anaconda-dir)
    (conda-env-home-directory my-anaconda-dir)
    (conda-message-on-environment-switch nil)
    :config
    (conda-env-initialize-interactive-shells)
    (conda-env-initialize-eshell)
    (conda-env-autoactivate-mode 1)
    ;; Set conda environment when file is opened
    (add-hook 'find-file-hook
              (lambda ()
                (when (bound-and-true-p conda-project-env-path)
                  (conda-env-activate-for-buffer))))
    ;; Set conda environment when desktop-mode restores file
    (add-to-list 'desktop-locals-to-save 'conda-project-env-path))
#+end_src

[[info:elisp#Desktop Save Mode][Desktop Save Mode]] saves the current state of Emacs' buffers and
windows at shutdown in a file [[file:.emacs.desktop][.emacs.desktop]]. Some buffer-local
variables are saved, but not all. Here I assume that any file buffer
from a Conda environment has a value for [[help:conda-project-env-path][conda-project-env-path]], which
points to the relevant Conda environment for the project. (This
buffer-local variable is usually set in a [[info:emacs#Directory Variables][.dir-locals.el]] file found at
the project level.)

I ensure that =desktop-mode= saves this variable by adding it to the
list [[help:desktop-locals-to-save][desktop-locals-to-save]], and I then advise the default function
[[help:desktop-restore-file-buffer][desktop-restore-file-buffer]] that =desktop-mode= uses to restore files,
such that it calls [[help:conda-env-activate-for-buffer][conda-env-activate-for-buffer]] after restoring the
buffer. This advice follows:

#+begin_src emacs-lisp
  (advice-add
   'desktop-restore-file-buffer :after
   (defalias 'my-desktop-restore-conda-env
     (lambda (file-name buffer-name desktop-misc)
       (when (bound-and-true-p conda-project-env-path)
         (conda-env-activate-for-buffer)))))
#+end_src

See code in this [[https://www.reddit.com/r/emacs/comments/162cjki/restore_desktop_for_cloned_indirect_buffers_that/][Reddit post]] for another example of advising the
default function [[help:desktop-restore-file-buffer][desktop-restore-file-buffer]] that =desktop-mode= uses to
restore configurations upon emacs startup.

An earlier attempt that worked only for =python-mode=.
#+begin_src emacs-lisp :tangle no
  (defun my-restore-conda-env (file-name buffer-name desktop-misc)
    "Run by 'desktop-read' to restore conda environment for buffer."
    (let ((buffer (desktop-restore-file-buffer file-name buffer-name desktop-misc)))
      (with-current-buffer buffer
        (conda-env-activate-for-buffer))
      buffer))
#+end_src

** Junkyard

#+begin_src emacs-lisp
  (defun my-conda-postactivate ()
    (message "--- in conda-postactivate hook")
    (message "--- current-buffer is %s" (current-buffer))
    (message "--- conda-env-current-name is '%s'" conda-env-current-name)
    (message "--- conda-env-current-path is '%s'" conda-env-current-path)
    (if (bound-and-true-p conda-project-env-path)
        (message "--- conda-project-env-path is '%s'" conda-project-env-path)
      (message "--- conda-project-env-path is not bound")))
  (defun my-conda-postdeactivate ()
    (message "--- in conda-postdeactivate hook")
    (message "--- current-buffer is %s" (current-buffer))
    (message "--- conda-env-current-name is '%s'" conda-env-current-name)
    (message "--- conda-env-current-path is '%s'" conda-env-current-path)
    (if (bound-and-true-p conda-project-env-path)
        (message "--- conda-project-env-path is '%s'" conda-project-env-path)
      (message "--- conda-project-env-path is not bound")))
#+end_src

Configuration from [[https://www.reddit.com/r/emacs/comments/n1gkkk/doom_emacs_pyright_lsp_conda/][Doom Emacs + Pyright + LSP + Conda]].
#+begin_src emacs-lisp :tangle no
  (use-package lsp-pyright
    :ensure t
    :after (python lsp-mode conda)
    :hook ((python-mode . (lambda () (require 'lsp-pyright)))
           (python-mode . lsp))
    ;; :custom
    ;; (lsp-pyright-venv-path (getenv "VIRTUAL_ENV"))
    :config
    ;; these hooks can't go in the :hook section since
    ;; lsp-restart-workspace is not available if lsp isn't active
    (add-hook 'conda-postactivate-hook (lambda () (lsp-restart-workspace)))
    (add-hook 'conda-postactivate-hook #'my-conda-postactivate)
    (add-hook 'conda-postdeactivate-hook (lambda () (lsp-restart-workspace)))
    (add-hook 'conda-postdeactivate-hook #'my-conda-postactivate))
#+end_src

Tell =lsp-pyright= about conda environments, from [[https://github.com/emacs-lsp/lsp-pyright/issues/52][here]].
#+begin_src emacs-lisp :tangle no
  (with-eval-after-load 'conda
    (with-eval-after-load 'lsp-pyright
      (progn
        (defun autoenv-for-lsp-pyright ()
          (let* ((env-name (conda--infer-env-from-buffer))
                 (env-path (concat conda-env-home-directory "/envs/" env-name)))
            (setq-local lsp-pyright-venv-path env-path)
            (setq-local mode-line-process (concat "(" env-name ")"))
            (message "setting lsp-pyright-venv-path to %s" env-path))
          )
        (push 'autoenv-for-lsp-pyright python-mode-hook)
        )))
#+end_src

* Testing

** Pytest

In order to run tests that generate plots, the following should appear in the
=pyproject.toml= file:

#+begin_quote
[tool.pytest.ini_options]
pythonpath = [".", "tests"]
testpaths  = ["tests"]
markers    = ["plot: mark a test that generates a plot."]
#+end_quote

The decoration
#+begin_src python
@pytest.mark.plot
#+end_src
marks a function as one that generates a plot. See =pytest= [[https://doc.pytest.org/en/latest/example/markers.html#mark-examples][docs]].

My own modified version of the pytest package. The original doesn't work well
on Windows.
#+begin_src emacs-lisp
  (use-package pytest
    :ensure nil
    :demand
    :load-path "lisp"
    :custom
    (pytest-global-name "pytest")
    (pytest-cmd-flags "-rx --disable-warnings")
    (pytest-enable-minor-mode t)
    :bind (:map python-mode-map
                ("C-c a"   . my-pytest-all-tests)
                ("C-c C-a" . my-pytest-all-plots)
                ("C-c m"   . my-pytest-module-tests)
                ("C-c C-m" . my-pytest-module-plots)
                ("C-c d"   . my-pytest-directory-tests)
                ("C-c C-d" . my-pytest-directory-plots)
                ("C-c o"   . pytest-one)
                ("C-c C-o" . pytest-one))
    :init
    (defun my-pytest-all-tests ()
      "Run all tests, skipping functions marked 'plot'."
      (interactive)
      (pytest-all (concat "-m \"not plot\" " pytest-cmd-flags)))
    (defun my-pytest-all-plots ()
      "Run all tests, running only functions marked 'plot'."
      (interactive)
      (pytest-all (concat "-m plot " pytest-cmd-flags)))
    (defun my-pytest-module-tests ()
      "Run pytest on a module, skipping functions marked 'plot'."
      (interactive)
      (pytest-module (concat "-m \"not plot\" " pytest-cmd-flags)))
    (defun my-pytest-module-plots ()
      "Run pytest on a module, running only functions marked 'plot'."
      (interactive)
      (pytest-module (concat "-m plot " pytest-cmd-flags)))
    (defun my-pytest-directory-tests ()
      "Run pytest on a directory, skipping functions marked 'plot'."
      (interactive)
      (pytest-directory (concat "-m \"not plot\" " pytest-cmd-flags)))
    (defun my-pytest-directory-plots ()
      "Run pytest on a directory, running only functions marked 'plot'."
      (interactive)
      (pytest-directory (concat "-m plot " pytest-cmd-flags))))
#+end_src

** List Python function names

#+begin_src emacs-lisp
  (defun my-python-function-name ()
    "Return the name of the Python function definition containing point."
    (save-excursion
      (when (python-nav-beginning-of-defun)
        (let ((start (progn (search-forward "def ") (point)))
              (end (progn (search-forward "(") (- (point) 1))))
          (buffer-substring-no-properties start end)))))
#+end_src

** Find monitor and frame attributes

#+begin_src emacs-lisp
  (defun names= (alist1 alist2)
    "Test whether the `name' attribute of ALIST1 is the same as the
  `name' attribute of ALIST2."
    (string= (alist-get 'name alist1) (alist-get 'name alist2)))
#+end_src

Find the attributes of a second monitor, if it exists.
#+begin_src emacs-lisp
  (defun my-other-monitor-attributes ()
    "Return the attributes of a monitor other than the one displaying
  the selected frame. If there is only one monitor, return that
  monitor's attributes."
    (let ((attrs
           (car (seq-filter
                 (lambda (attrs) (not (names= (frame-monitor-attributes) attrs)))
                 (display-monitor-attributes-list)))))
      (or attrs (frame-monitor-attributes))))

  (defun my-other-monitor-attribute (key)
    "Return monitor atttribute indexed by KEY on the other monitor."
    (alist-get key (my-other-monitor-attributes)))
#+end_src

Frame predicate for ~display-buffer-use-some-frame~. Returns `t' iff the
frame contains one or more buffers with name matching a regexp.
#+begin_src emacs-lisp
  (defun my-pytest-frame-p (frame &optional name-rx)
    "Test whether FRAME has a buffer with name matching NAME-RX,
  whether or not that buffer is visible or buried. If NAME-RX is
  not specified or nil, use '\\*pytest'."
    (let ((regexp (or name-rx "\\*pytest"))
          (visible-names (mapcar #'buffer-name (frame-parameter frame 'buffer-list)))
          (buried-names (mapcar #'buffer-name (frame-parameter frame 'buried-buffer-list))))
      (cl-some
       (apply-partially #'string-match-p regexp)
       (append visible-names buried-names))))
#+end_src

Filter all frames in a particular monitor.
#+begin_src emacs-lisp
  (defun my-pytest-filter-frames (monitor-attrs &optional name-rx)
    "Filter the `frames' attribute of MONITOR-ATTRS using the
  predicate `my-pytest-frame-p'. Returns a copy of MONITOR-ATTRS
  with a new `frames' attribute."
    (let ((filter-fn))
      (if name-rx
          (setf filter-fn (lambda (frame) (my-pytest-frame-p frame name-rx)))
        (setf filter-fn #'my-pytest-frame-p))
      (let ((filtered-frames
             (seq-filter
              filter-fn
              (alist-get 'frames monitor-attrs))))
        (alist-modify monitor-attrs 'frames filtered-frames))))
#+end_src

Return the first frame found on a monitor that contains a buffer with
matching name.
#+begin_src emacs-lisp
  (defun my-pytest-get-frame (&optional monitor-attrs name-rx)
    "Return the first frame in MONITOR-ATTRS found that contains a
  buffer matching NAME-RX. If MONITOR-ATTRS is nil, use the monitor
  attributes of the monitor other than the one currently in use."
    (let* ((attrs (or monitor-attrs (my-other-monitor-attributes)))
           (matches (my-pytest-filter-frames attrs name-rx)))
      (car (alist-get 'frames matches))))
#+end_src

** Modify =popper='s display function

#+begin_src emacs-lisp
    (defun my-pytest-popper-display-frame (buffer &optional alist plist)
      ""
      (let* ((pytest-frame (or
                            (my-pytest-get-frame (my-other-monitor-attributes))
                            (car (my-other-monitor-attribute 'frames))
                            ;; (my-pytest-get-frame (frame-monitor-attributes))
                            (make-frame-on-monitor
                             (my-other-monitor-attribute 'name)
                             nil
                             '((user-position . t)
                               (top . 157)
                               (left . 1089)
                               (width . 111)
                               (height . 69)))))
             (my-alist '((inhibit-same-window . nil)
                         (inhibit-switch-frame . nil)
                         (reusable-frames . pytest-frame))))
        (display-buffer-use-some-frame buffer my-alist)
        (select-window (get-buffer-window buffer pytest-frame))))
#+end_src

Make =popper= display *pytest* buffers using my own display function.
#+begin_src emacs-lisp :tangle no
  (defun my-popper-select-popup-at-bottom (buffer &optional alist)
    "Display and switch to popup-buffer BUFFER at the bottom of the screen,
  unless BUFFER is named '*pytest*'."
    (if (string-match-p "\\*pytest\\*" (buffer-name buffer))
        (my-pytest-popper-display-frame buffer alist)
      (popper-select-popup-at-bottom buffer alist)))
#+end_src

Set the =popper= display function.
#+begin_src emacs-lisp :tangle no
  (popper-mode -1)
  (setq popper-display-function #'my-popper-select-popup-at-bottom)
  (popper-mode +1)
#+end_src

** Junkyard

#+begin_src emacs-lisp :tangle no
    (defun my-pytest-all (arg)
      (interactive "P")
      (if arg
          (call-interactively #'pytest-pdb-all)
        (call-interactively #'pytest-all)))
    (defun my-pytest-directory (arg)
      (interactive "P")
      (if arg
          (call-interactively #'pytest-pdb-directory)
        (call-interactively #'pytest-directory)))
    (defun my-pytest-module (arg)
      (interactive "P")
      (if arg
          (call-interactively #'pytest-pdb-module)
        (call-interactively #'pytest-module)))
    (defun my-pytest-one (arg)
      (interactive "P")
      (if arg
          (call-interactively #'pytest-pdb-one)
        (call-interactively #'pytest-one)))
#+end_src

From [[https://e17i.github.io/articles-emacs-display-1/][Configuring the emacs display system]].
#+begin_src emacs-lisp :tangle no
  (defun push-buffer-to-frame ()
    "push current window buffer to own frame and revert current window to previous frame."
    (interactive)
    (let ((current (current-buffer))
          (selected (selected-window)))
      (if (display-buffer-other-frame current)
          (quit-restore-window selected))))
#+end_src

From [[https://emacs.stackexchange.com/questions/60558/controlling-behaviour-of-compilation-window-creation][Controlling behavior of compilation window creation]].
#+begin_src emacs-lisp :tangle no
(setq display-buffer-alist
      `((,(rx bos
              (| (literal "*compilation")
                 (literal "*shell")
                 (literal "*eshell")
                 (literal "*Compile-Log")))
         display-buffer-in-direction
         (window .                      ;reference window
                 t) ;either `t' (selected window), `main', `root', or an arbitrary valid window
         (direction .
                    below)              ;`below' (window) or `bottom' (of frame)
         (window-height . 0.33)          ;absolute (10) or relative (0.3)
         )))
#+end_src

Predicates for matching frame and monitor names.
#+begin_src emacs-lisp :tangle no
  (defun my-pytest-frame-p (name-regexp &optional frame)
    "Test whether FRAME has name matching NAME-REGEXP."
    (let ((params (frame-parameters frame)))
      (string-match-p name-regexp (alist-get 'name params))))

  (defun my-pytest-monitor-p (name-regexp monitor-attrs)
    "Test whether MONITOR-ATTRS has name matching NAME-REGEXP."
    (string-match-p name-regexp (alist-get 'name monitor-attrs)))
#+end_src

Finds matching monitor attributes alists.
#+begin_src emacs-lisp :tangle no
  (defun my-find-monitor-attributes-by-name (name-regexp)
    "Return the first set of monitor attributes found with name
  matching NAME-REGEXP. If NAME-REGEXP is blank or nil, return nil."
    (if (or (not name-regexp) (string-blank-p name-regexp))
        nil
      (car (seq-filter
            (apply-partially #'my-pytest-monitor-p name-regexp)
            (display-monitor-attributes-list)))))
#+end_src

Removes non-matching frames from a monitor attributes alist.
#+begin_src emacs-lisp :tangle no
  (defun my-filter-frames-by-name (monitor-attrs frame-name-regexp)
    "Returns a modified monitor attributes alist with frames having
  names matching FRAME-NAME-REGEXP. All other frames are removed
  from `frames' list. MONITOR-ATTRS is the original monitor
  attributes alist."
    (let ((filtered-frames
           (seq-filter
            (apply-partially #'my-pytest-frame-p frame-name-regexp)
            (alist-get 'frames monitor-attrs))))
      (alist-modify monitor-attrs 'frames filtered-frames)))
#+end_src

Removes non-matching frames from all monitor attributes alists.
#+begin_src emacs-lisp :tangle no
  (defun my-filter-all-frames-by-name (frame-name-regexp)
    "Return a list of monitor attribute alists with all frames having
  names not matching FRAME-NAME-REGEXP removed."
    (mapcar
     (apply-partially #'my-filter-frames-by-name frame-name-regexp)
     (display-monitor-attributes-list)))
#+end_src

A Magit-like emacs interface to Pytest ([[https://github.com/wbolster/emacs-python-pytest][python-pytest]]).
#+begin_src emacs-lisp :tangle no
  (use-package python-pytest
    :disabled
    :ensure t)
#+end_src
